回过头来还是想好好把自己的心得写写，看到自己之前做的像一团不知道什么东西拼起来的项目，，，心里很不是滋味，总感觉是为了写代码而写代码，尤其是在看到JM19.0那优美的代码之后，有种很难受的感觉。

# 正文

## 导语

CABAC Context-based Adaptive Binary Arithmetic Coding
按照标准里面的说来翻译过来就是：基于上下文自适应的二进制算术编码

算术编码是什么，什么叫做基于上下文？什么又叫自适应，

## 开始

标准中按照函数的思想来解释了每一步需要什么，本文类似。
entropy\_coding\_mode\_flag 标志了在解码中是否会用到ae算子
ae算子
输入：句法元素请求
输出：句法元素的值

句法元素的索引：binIdx
上下文的索引：ctxIdx
![CABAC解码流程](/img/bVcPtce)
这张图在标准P237，大致看出来有三个主要的流程

1. 初始化
2. 获得二值化
3. 获得上下文
4. 解二进制位
5. 解二进制串
6. 后处理

初始化
上下文表一共有两个条目
上下文索引 **ctxIdx** ,上一次的二进制值 **binVal**
上下文索引一共是1024个，分成43组，多个上下文可以分给同一个句法元素，表示这个句法元素不同二进制位的解码状态
这张表，也就相当于我们在解码过程中需要的“码表”，只不过他是动态的
初始化就是告诉了初始的码表，这个是固定的，

初始化有两种情况：初始化cabac全状态，初始化cabac引擎

二值化

输入：句法元素请求
输出：二值化，**maxBinIdxCtx**, **ctxIdxOffset**, and **bypassFlag**

|x|0|1|2|3|4|5|6|
|--|--|--|--|--|--|--|--|
|0|0|\|\|\|\|\|\|
|1|1|0|0|\|\|\|\|
|2|1|0|1|\|\|\|\|
|3|1|1|0|0|0|0|\|
|4|1|1|0|0|0|1|\|
|5|1|1|0|0|1|0|\|
|6|1|1|0|0|1|1|\|
|7|1|1|0|1|0|0|\|
|8|1|1|0|1|0|1|\|
|9|1|1|0|1|1|0|\|
|10|1|1|0|1|1|1|\|
|12|1|1|1|0|0|0|0|
|13|1|1|1|0|0|0|1|
|14|1|1|1|0|0|1|0|
|15|1|1|1|0|0|1|1|
|16|1|1|1|0|1|0|0|
|17|1|1|1|0|1|0|1|
|18|1|1|1|0|1|1|0|
|19|1|1|1|0|1|1|1|
|20|1|1|1|1|0|0|0|
|21|1|1|1|1|0|0|1|
|23|1|1|1|1|0|1|\|
|11|1|1|1|1|1|0|\|
|22|1|1|1|1|1|1|\|
